var forge = require('node-forge');
var fs = require('fs');
var net = require('net');

/**
 * Normalizes the attrs object into a certificate friendly array.
 *
 * @param {Object.<string>} attrs The attributes object.
 * @return {Array.<Object>} The normalized attributes.
 * @private
 */
function attributes(attrs) {
  // TODO: populate defaults?
  attrs || (attrs = {
    name: 'example.org',
    country: 'US',
    state: 'Virginia',
    city: 'Blacksburg',
    organization: 'Test',
    unit: 'Test'
  });
  return [{
    name: 'commonName',
    value: attrs.name
  }, {
    name: 'countryName',
    value: attrs.country || 'US'
  }, {
    name: 'stateOrProvinceName',
    value: attrs.state || attrs.province
  }, {
    name: 'localityName',
    value: attrs.city || attrs.locality
  }, {
    name: 'organizationName',
    value: attrs.organization
  }, {
    name: 'organizationalUnitName',
    value: attrs.unit
  }];
}

/**
 * Injects formatted alternates into the extensions array.
 *
 * @param {?Array.<string|Object>} alt The alternates array.
 * @param {Array.<Object>} ext The extensions array.
 * @return {Array.<Object>} Returns ext.
 * @private
 */
function alt(alt, ext) {
  if (!Array.isArray(alt) || !alt.length) {
    return ext;
  }
  var res = new Array(alt.length);
  for (var i = alt.length - 1; i >= 0; i--) {
    if (typeof alt[i] === 'object' && alt[i] !== null) {
      res[i] = alt[i];
    } else if (net.isIP(alt[i])) {
      res[i] = {
        type: 7,
        ip: alt[i]
      };
    } else {
      res[i] = {
        type: 6,
        value: alt[i]
      };
    }
  }
  ext.push({
    name: 'subjectAltName',
    altNames: res
  });
  return ext;
}

/**
 * Checks if the provided object is a Date object, without using instanceof.
 *
 * @param {*} obj The object to check.
 * @return {boolean} Whether the object is a Date object.
 * @private
 */
function isDate(obj) {
  return Object.prototype.toString.call(obj) === '[object Date]';
}

/**
 * Normalizes the object to a date, accepts millisecond offset integers, Date
 * objects, or string timestamps. If none are provided, defaults to 1 year from
 * today.
 *
 * @param {*} obj The object to normalize, if possible.
 * @return {Date} The Date object.
 * @private
 */
function normDate(obj) {
  if (obj === +obj)
    return new Date(Date.now() + obj);
  if (isDate(obj))
    return obj;
  if (typeof obj === 'string')
    return new Date(obj);
  // default to one year
  var date = new Date();
  date.setFullYear(date.getFullYear() + 1);
  return date;
}

/**
 * Generate a self-signed public-private RSA keypair with given parameters.
 *
 * Attributes is an object including the following properties:
 *   name
 *   country (defaults to 'US')
 *   state
 *   city
 *   organization
 *   unit
 *
 * Options can include the following options:
 *   keySize (default 1024)
 *   serial  (serial number for CA certificate, defaults to '01')
 *   expire  (default 1 year, accepts millisecond integer, string timestamp or
 *            Date)
 *   alt     (array of alternates names, either ip addresses or urls, defaults
 *            to none)
 *   pkcs7   (whether to protect with PKCS#7, defaults to false)
 *
 * @param {Object.<string>} attrs The CA attributes.
 * @param {Object=} options The options for the keypair.
 * @public
 */
function generate(attrs, options) {
  options || (options = {});

  // generate the keypair
  var keys = forge.pki.rsa.generateKeyPair(options.keySize || 1024);

  // create the certificate
  var cert = forge.pki.createCertificate();

  // serial and date handling
  cert.serialNumber = options.serial || '01';
  cert.validity.notBefore = new Date();
  cert.validity.notAfter = normDate(options.expire);

  // render attributes
  attrs = attributes(attrs);

  // set attributes
  cert.setSubject(attrs);
  cert.setIssuer(attrs);

  // add common cert extensions
  var extensions = [{
    name: 'basicConstraints',
    cA: true
  }, {
    name: 'keyUsage',
    keyCertSign: true,
    digitalSignature: true,
    nonRepudiation: true,
    keyEncipherment: true,
    dataEncipherment: true
  }, {
    name: 'extKeyUsage',
    serverAuth: true,
    clientAuth: true,
    codeSigning: true,
    emailProtection: true,
    timeStamping: true
  }];

  // add alternate names, if applicable
  alt(options.alt, extensions);

  // set extensions
  cert.setExtensions(extensions);

  // use publickey in cert
  cert.publicKey = keys.publicKey;

  // sign the private key with the certificate
  cert.sign(keys.privateKey);

  // create the pem object
  var pem = {
    private: forge.pki.privateKeyToPem(keys.privateKey),
    public: forge.pki.publicKeyToPem(keys.publicKey),
    cert: forge.pki.certificateToPem(cert)
  };

  // protect with PKCS#7
  if (options.pkcs7) {
    var p7 = forge.pkcs7.createSignedData();
    p7.addCertificate(cert);
    pem.pkcs7 = forge.pkcs7.messageToPem(p7);
  }

  // add certificate to a CA store for verification
  var caStore = forge.pki.createCaStore();
  caStore.addCertificate(cert);

  // verify, the error will bubble because verifyCertificateChain is synchronous
  try {
    forge.pki.verifyCertificateChain(caStore, [cert],
      function(vfd, depth, chain) {
        if (vfd !== true) {
          throw new Error('certificate could not be verified');
        }
        return true;
    });
  } catch(err) {
    // only throw new Error if not already an error object
    if (!(err instanceof Error)) {
      throw new Error(err);
    }
    throw err;
  }

  return pem;
}

// backwards compatibility
generate.generate = generate;

generate.attributes = attributes;
generate.alternates = alt;
generate.date = normDate;

// main export is generate function
module.exports = generate;
